\fancypagestyle{plain}{%
  \fancyhf{}%
  \fancyhead[L]{\footnotesize\href{https://github.com/DSR3164/sdr/tree/v4}{github.com/DSR3164/sdr/tree/v4}}%
  \fancyhead[R]{\hypersetup{hidelinks}\qrcode[height=1.4cm]{https://github.com/DSR3164/sdr/tree/v4}}
  \fancyfoot[C]{\thepage}
}

\chapter*{\practicetitle} %Имитация аналоговой передачи звука и его приём на SDR. Влияние чувствительности и усиления
\textbf{Цель работы:} Исследование влияния шума, чувствительности и усиления на качество сигнала. Создание алгоритмов конвертации audio$\rightarrow$pcm$\rightarrow$samples$\rightarrow$pcm$\rightarrow$audio
\addcontentsline{toc}{section}{\MakeUppercase{Цель работы}}

\sect{Краткие теоретические сведения}
\textbf{Чувствительность приёмника} определяет минимальный уровень сигнала, который можно различить на фоне собственного шума тракта. Усиление RX/TX влияет на амплитуду принимаемых и передаваемых выборок: чрезмерное усиление приводит к насыщению и искажению, недостаточное — к снижению отношения сигнал/шум.
\textbf{Усиление} — это коэффициент усиления, который определяет, насколько сильно цифровые I/Q-выборки будут увеличены перед подачей на ЦАП/АЦП. Малое значение даёт слишком слабый радиосигнал, большое — вызывает перегрузку тракта, искажения и спектральные выбросы. Правильный выбор усиления — это подбор уровня, при котором передатчик работает в линейном режиме и форма сигнала соответствует исходным выборкам.

\textbf{Шум} в SDR — это смесь теплового шума, квантования АЦП, помех тракта и внешних источников. Вся обработка в итоге сводится к контролю уровней усиления, динамического диапазона и сохранению линейности канала. Корректное кодирование PCM и обратное преобразование позволяют восстановить исходный аудиосигнал, если цепочка audio$\rightarrow$PCM$\rightarrow$samples$\rightarrow$PCM$\rightarrow$audio не вносит систематических искажений.

\sect{Ход работы}

Для начала необходимо подготовить аудиофайл в формате PCM. Исходный файл в формате MP3 был конвертирован в PCM с помощью следующего скрипта на Python:
\begin{mdframed}
\begin{minted}{python}
import numpy as np
import librosa
from pydub import AudioSegment


#------------MP3==>PCM-------------
y, sr = librosa.load("../1.mp3", sr=44100, mono=False)
if y.ndim == 2:
    y = y.T.reshape(-1)
pcm_data = (y * 32767).astype(np.int16)
pcm_data.tofile("../1.pcm")
\end{minted}
\end{mdframed}

Далее была использована следующая функция для чтения PCM в C++:
\begin{mdframed}
\begin{minted}{cpp}
int16_t *read_pcm(const char *filename, size_t *sample_count)
{
    FILE *file = fopen(filename, "rb");
    
    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    fseek(file, 0, SEEK_SET);
    printf("file_size = %ld\n", file_size);
    
    *sample_count = file_size / sizeof(int16_t);
    int16_t *samples = (int16_t *)malloc(file_size);
    size_t sf = fread(samples, sizeof(int16_t), *sample_count, file);
    
    if (sf == 0){
        printf("file %s empty!", filename);
    }
    
    fclose(file);
    
    return samples;
}
\end{minted}
\end{mdframed}

После чтения PCM-файла, буферы заполняются отчетами и передаются на передачу и приём с помощью следующего кода:
\begin{mdframed}
\begin{minted}{cpp}
    size_t sample_count = 0;
    int16_t *samples = read_pcm(filename, &sample_count);
    if (!samples) return 1;
    int buffs_size = tx_mtu;
    int buffs_count = (sample_count/buffs_size);
    int remainder = sample_count - buffs_count * buffs_size;
    int full_size = buffs_count + (int)(bool)remainder;
    printf("Количество сэмплов: %ld\nКоличество буферов: %ld == %d по %d + %d\n", sample_count, full_size, buffs_count, buffs_size, remainder);

    // Количество итерация чтения из буфера
    size_t iteration_count = 10;
    long long last_time = 0;
    
    FILE* file = fopen("../2.pcm", "wb");
    int16_t *rx_buffer = (int16_t *)malloc((rx_mtu * 2 * sizeof(int16_t)));

    void *rx_buffs[] = {rx_buffer};
    int flags;        // flags set by receive operation
    long long timeNs; //timestamp for receive buffer
    long timeoutUs = 400000;
    
    flags = SOAPY_SDR_HAS_TIME;
    for (size_t b = 0; b < full_size; b++)
    {
        size_t current_size = (b == full_size - 1 && remainder > 0) ? remainder : buffs_size;
        const void *one_buff = samples + b * buffs_size * 2;
        
        int sr = SoapySDRDevice_readStream(sdr, rxStream, rx_buffs, rx_mtu, &flags, &timeNs, timeoutUs);
        
        long long tx_time = timeNs + (4 * 1000 * 1000); // на 4 [мс] в будущее
        
        int st = SoapySDRDevice_writeStream(sdr, txStream, &one_buff, tx_mtu, &flags, tx_time, timeoutUs);
        
        if (st < 0)
        printf("TX Failed on buffer %zu: %i\n", b, st);
        fwrite(rx_buffer, 2 * rx_mtu * sizeof(int16_t), 1, file);
        last_time = tx_time;
        printf("Buffer: %lu - Samples: %i, Flags: %i, Time: %lli, TimeDiff: %lli\n", b, sr, flags, timeNs, (timeNs - last_time) * (last_time > 0));
    }
\end{minted}
\end{mdframed}

После выполнения передачи и приёма, полученный PCM-файл был конвертирован обратно в MP3 с помощью следующего скрипта на Python:
\begin{mdframed}
\begin{minted}{python}
#------------PCM==>MP3-------------
pcm_data = np.fromfile("../2.pcm", dtype=np.int16)
mono_stereo = 2
audio = AudioSegment(data=pcm_data.tobytes(), sample_width=2, frame_rate=44100, channels=mono_stereo)
audio.export("../2.mp3", format="mp3", bitrate="159k")
\end{minted}
\end{mdframed}
В при передачи сигнала в "аналоговом" виде любой шум влиял на значения и итоговый звук изменялся, результат сложения двух сигналов - \href{https://github.com/DSR3164/sdr/blob/3507d37543b31e96a6068d0a7a81cbbd5b161162/pluto/dev/2.mp3}{2.mp3} - первые 3 секунды - исходный сигнал (хорошо различимый), далее - сигнал с шумом.

\sect{Вывод}
В ходе работы была реализована последовательная схема преобразования аудиоданных: mp3 $\rightarrow$ PCM $\rightarrow$ набор отсчётов $\rightarrow$ PCM $\rightarrow$ аудио. Практическая реализация конвертаций позволила подтвердить корректность обработки сигнала в каждом из этапов и обеспечить восстановление исходного звучания после передачи данных в виде необработанных PCM-отсчётов.
Эксперимент показал, что качество восстановленного сигнала существенно зависит от уровня шума, параметров чувствительности и усиления при передаче через тракт.