\fancypagestyle{plain}{%
  \fancyhf{}%
  \fancyhead[L]{\footnotesize\href{https://github.com/DSR3164/sdr/tree/v5}{github.com/DSR3164/sdr/tree/v5}}%
  \fancyhead[R]{\hypersetup{hidelinks}\qrcode[height=1.4cm]{https://github.com/DSR3164/sdr/tree/v5}}
  \fancyfoot[C]{\thepage}
}

\chapter*{\practicetitle} %Моделирование формирования и приёма QPSK. Реализация приёма и передачи BPSK. Алгоритм дискретной свёртки.
\textbf{Цель работы:} Реализовать формирование и передачу/прием QPSK/BPSK-сигнала. Разработать алгоритм дискретной свёртки для фильтра.
\addcontentsline{toc}{section}{\MakeUppercase{Цель работы}}

\sect{Краткие теоретические сведения}
В \textbf{QPSK} (Quadrature Phase Shift Keying) информация кодируется изменением фазы несущего сигнала в четырёх возможных состояниях, что позволяет передавать два бита на символ. В \textbf{BPSK} (Binary Phase Shift Keying) используется два состояния фазы, что позволяет передавать один бит на символ.

\textbf{Mapper} - блок, преобразующий входную битовую последовательность в последовательность комплексных символьных значений (модуляция). Для QPSK используется по два бита на символ, для BPSK - один бит.

\textbf{Upsampler} - (нулевой вставщик) увеличивает частоту дискретизации последовательности символов, вставляя между соседними символами $L-1$ нулевых отсчётов, где $L$ - фактор апсемплинга.
Upsampler подготавливает дискретную последовательность для последующей фильтрации (pulse shaping) и цифрового преобразования на несущую. Фактически он задаёт число отсчётов на символ.

\textbf{Pulse shaping filter} - (формирующий фильтр) ограничивает спектр сигнала, уменьшает межсимвольную интерференцию (ISI) и задаёт желаемую временную форму символа. Как правило, корневой фильтр Найквиста (например, root-raised cosine) - выполняет свёртку передискретизированной последовательности символов с импульсной характеристикой, удовлетворяющей критерию отсутствия межсимвольной интерференции в момент выборки.

\textbf{Constellation diagram} - (сигнальное созвездие) представление всевозможных значений комплексной амплитуды манипулированных радиосигналов на комплексной плоскости.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.45\textwidth, keepaspectratio]{images/\practicenumber/bpsk_const_diagram}
  \includegraphics[width=0.45\textwidth, keepaspectratio]{images/\practicenumber/qpsk_const_diagram}
  \caption{Сигнальное созвездие BPSK и QPSK}
\end{figure}

\sect{Ход работы}
В данной работе была реализована передача только QPSK сигнала 

Для начала необходимо реализовать маппер. 

Mapper QPSK:
\begin{mdframed}
\begin{minted}{cpp}
void mapper_q(const vector<int> &bits, vector<cp> &symbols)
{
    /*
    Map input bits to QPSK symbols and store them in 'symbols'.
    'bits' is the input vector of bits (0s and 1s).
    'symbols' is the output vector of complex symbols.
    00 -> +1 + 1j
    01 -> +1 - 1j
    10 -> -1 + 1j
    11 -> -1 - 1j
    */

    for (size_t i = 0; i < symbols.size(); ++i)
        symbols[i] = cp(bits[2 * i] * -2.0 + 1.0, bits[2 * i + 1] * -2.0 + 1.0);
}
\end{minted}
\end{mdframed}

Mapper BPSK:
\begin{mdframed}
\begin{minted}{cpp}
void mapper_b(const vector<int> &bits, vector<cp> &symbols)
{
    /*
    Map input bits to BPSK symbols and store them in 'symbols'.
    'bits' is the input vector of bits (0s and 1s).
    'symbols' is the output vector of complex symbols.
    0 -> +1 + 0j
    1 -> -1 - 0j
    */

    for (size_t i = 0; i < symbols.size(); ++i)
        symbols[i] = cp(bits[i] * -2.0 + 1.0, 0.0);
}
\end{minted}
\end{mdframed}

После реализации маппера был реализован апсемплер:
\begin{mdframed}
\begin{minted}{cpp}
void upsample(const vector<cp> &symbols, vector<cp> &upsampled, int up = 10)
{
    /*
    Upsample the input symbols with zeros by a factor of 'up' and store the result in 'upsampled'.
    'symbols' is the input vector of complex symbols.
    'upsampled' is the output vector of complex samples after upsampling.
    'up' is the upsampling factor (default is 10).
    */

    if (upsampled.size() < symbols.size() * up)
    {
        printf("Ошибка: недостаточный размер вектора для апсемплинга!\n");
        return;
    }
    fill(upsampled.begin(), upsampled.end(), cp(0, 0));

    for (size_t i = 0; i < symbols.size(); ++i)
    {
        upsampled[i * up] = symbols[i];
    }
}
\end{minted}
\end{mdframed}

Функция формирующего фильтра (дискретная свёртка):
\begin{mdframed}
\begin{minted}{cpp}
void filter_i(const vector<cp> &a, const vector<double> &b, vector<int> &y)
{
    /*
    Convolve input signal 'a' with filter coefficients 'b' and store the result in 'y'.
    'a' is a vector of complex samples.
    'b' is a vector of filter coefficients (real numbers), constant 1 in our case.
    'y' is the output vector of integers (filtered signal).
    */
    const int nb = b.size();
    const int na = a.size();

    y.assign(na, 0);

    for (int n = 0; n < na; ++n)
    {
        int acc = 0;
        for (int m = 0; m < nb; ++m)
        {
            if (n - m >= 0)
                acc += a[n - m].real() * b[m];
        }
        y[n] = acc;
    }
}
\end{minted}
\end{mdframed}

Функция формирующего фильтра (дискретная свёртка) - мнимая часть:
\begin{mdframed}
\begin{minted}{cpp}
void filter_q(const vector<cp> &a, const vector<double> &b, vector<int> &y)
{
    /*
    Convolve input signal 'a' with filter coefficients 'b' and store the result in 'y'.
    'a' is a vector of complex samples.
    'b' is a vector of filter coefficients (real numbers), constant 1 in our case.
    'y' is the output vector of integers (filtered signal).
    */
    const int nb = b.size();
    const int na = a.size();

    y.assign(na, 0);

    for (int n = 0; n < na; ++n)
    {
        int acc = 0;
        for (int m = 0; m < nb; ++m)
        {
            if (n - m >= 0)
                acc += a[n - m].imag() * b[m];
        }
        y[n] = acc;
    }
}
\end{minted}
\end{mdframed}

Полученный сигнал:
\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth, keepaspectratio]{images/\practicenumber/qpsk}
  \caption{Полученный QPSK сигнал}
\end{figure}
На графике так же можно заметить что сигналы I и Q лежат в пределах [-2048; 2047] что соответствует 12-битному АЦП.

\sect{Вывод}
В ходе работы были реализованы ключевые элементы цифрового тракта QPSK/BPSK: маппинг битовых последовательностей в комплексные символы, апсемплирование и дискретная свёртка с формирующим фильтром. Реализация показала, что даже минимальный набор алгоритмов обеспечивает корректное формирование временной структуры сигнала и отображение ожидаемого созвездия. Апсемплирование и фильтрация задали требуемую форму импульса и определили реальную динамику сигнала на уровне отсчётов, что подтверждается попадающими в 12-битный диапазон значениями I/Q.